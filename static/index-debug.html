<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Headspace - Debug Mode</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="js/procedural-geometry.js"></script>
    <script src="js/enrichment-stream.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0e27;
            color: #00ff00;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
        }

        #canvas-container {
            flex: 1;
            position: relative;
        }

        #side-panel {
            width: 400px;
            background: #001a33;
            border-left: 2px solid #00ff00;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #input-section {
            padding: 20px;
            border-bottom: 2px solid #00ff00;
        }

        #input-section h2 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #00ff00;
        }

        #document-title {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background: #0a0e27;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: monospace;
            font-size: 12px;
        }

        #document-content {
            width: 100%;
            height: 120px;
            padding: 8px;
            margin-bottom: 10px;
            background: #0a0e27;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: monospace;
            font-size: 12px;
            resize: none;
        }

        #process-btn {
            width: 100%;
            padding: 10px;
            background: #00ff00;
            color: #001a33;
            border: none;
            font-weight: bold;
            cursor: pointer;
            font-family: monospace;
            transition: all 0.2s;
        }

        #process-btn:hover {
            background: #00dd00;
            transform: scale(1.02);
        }

        #process-btn:disabled {
            background: #666;
            cursor: not-allowed;
            color: #333;
        }

        #console {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            font-size: 11px;
            line-height: 1.4;
            border-top: 2px solid #00ff00;
        }

        .log-line {
            margin-bottom: 4px;
            padding: 2px 5px;
        }

        .log-info {
            color: #00ff00;
        }

        .log-debug {
            color: #00aa00;
        }

        .log-warn {
            color: #ffaa00;
        }

        .log-error {
            color: #ff0000;
        }

        .log-success {
            color: #00ffaa;
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .status-bar {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            padding: 10px;
            border: 1px solid #00ff00;
            font-size: 12px;
            font-family: monospace;
            border-radius: 3px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div class="status-bar" id="status-bar">
                Chunks: 0 | Clusters: 0 | Embeddings: 0 | Geometry: 0
            </div>
        </div>
        <div id="side-panel">
            <div id="input-section">
                <h2>üìÑ Document Input</h2>
                <input
                    type="text"
                    id="document-title"
                    placeholder="Document title..."
                    value="My Document"
                >
                <textarea
                    id="document-content"
                    placeholder="Paste your document content here...&#10;&#10;Separate paragraphs with blank lines."
                ></textarea>
                <button id="process-btn">Process & Visualize</button>
            </div>
            <div id="console"></div>
        </div>
    </div>

    <script>
        // ===== LOGGING SYSTEM =====
        const consoleEl = document.getElementById('console');
        const logLevels = {
            DEBUG: 'log-debug',
            INFO: 'log-info',
            WARN: 'log-warn',
            ERROR: 'log-error',
            SUCCESS: 'log-success'
        };

        function log(level, message) {
            const timestamp = new Date().toLocaleTimeString();
            const className = logLevels[level] || 'log-info';
            const emoji = {
                DEBUG: 'üîç',
                INFO: '‚ÑπÔ∏è',
                WARN: '‚ö†Ô∏è',
                ERROR: '‚ùå',
                SUCCESS: '‚úÖ'
            }[level] || '‚Ä¢';

            const line = document.createElement('div');
            line.className = `log-line ${className}`;
            line.textContent = `[${timestamp}] ${emoji} ${message}`;

            consoleEl.appendChild(line);
            consoleEl.scrollTop = consoleEl.scrollHeight;

            console.log(`[${level}] ${message}`);
        }

        // ===== THREE.JS SETUP =====
        let scene, camera, renderer, controls;
        let chunkMeshes = new Map();
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let selectedMesh = null;
        let selectedDocumentId = null;
        let selectedNebulaId = null;
        let geometryGenerator = null;
        let rotationCenter = new THREE.Vector3(0, 0, 0); // Global rotation center

        function initScene() {
            const canvas = document.getElementById('canvas');

            // Initialize procedural geometry generator
            geometryGenerator = new ProceduralGeometryGenerator();
            log('INFO', 'Procedural geometry generator initialized');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x001a33);
            scene.fog = new THREE.Fog(0x001a33, 500, 2000);

            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 10000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Simple camera controls (mouse drag to rotate)
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
                // Update rotation center based on selection hierarchy
                updateRotationCenter();
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    // Rotate camera around rotation center (selected chunk or origin)
                    const relativePos = camera.position.clone().sub(rotationCenter);
                    const radius = relativePos.length();

                    const phi = Math.atan2(relativePos.z, relativePos.x) + deltaX * 0.01;
                    const theta = Math.acos(relativePos.y / (radius || 1)) + deltaY * 0.01;

                    relativePos.x = radius * Math.sin(theta) * Math.cos(phi);
                    relativePos.y = radius * Math.cos(theta);
                    relativePos.z = radius * Math.sin(theta) * Math.sin(phi);

                    camera.position.copy(relativePos.add(rotationCenter));
                    camera.lookAt(rotationCenter);

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoom = e.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(zoom);
            }, false);

            controls = {
                target: new THREE.Vector3(0, 0, 0),
                update: () => {},
                dispose: () => {}
            }; // Dummy controls object

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(100, 100, 100);
            scene.add(pointLight);

            // Starfield
            const starGeom = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 1000; i++) {
                vertices.push(
                    (Math.random() - 0.5) * 2000,
                    (Math.random() - 0.5) * 2000,
                    (Math.random() - 0.5) * 2000
                );
            }
            starGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 2 });
            const stars = new THREE.Points(starGeom, starMat);
            scene.add(stars);

            log('INFO', 'Three.js scene initialized');

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update();

                chunkMeshes.forEach(mesh => {
                    mesh.rotation.x += 0.0002;
                    mesh.rotation.y += 0.0003;
                });

                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            });

            // Click handler for chunk selection/deselection
            canvas.addEventListener('click', (event) => {
                if (event.button !== 0 || event.ctrlKey || event.metaKey) return; // Only left click, not drag

                const rect = canvas.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(Array.from(chunkMeshes.values()));

                if (intersects.length > 0) {
                    const mesh = intersects[0].object;
                    focusOnChunk(mesh);
                } else {
                    // Clicked empty space - deselect all
                    deselectAll();
                }
            });
        }

        // ===== API CALLS & STREAMING =====
        let enrichmentStream = null;

        async function processDocument() {
            const title = document.getElementById('document-title').value;
            const content = document.getElementById('document-content').value;
            const btn = document.getElementById('process-btn');

            if (!title || !content) {
                log('WARN', 'Please enter title and content');
                return;
            }

            btn.disabled = true;
            log('INFO', `Starting document processing: "${title}"`);
            log('DEBUG', `Content length: ${content.length} chars`);

            try {
                log('INFO', 'üöÄ Sending to API...');
                const response = await fetch('/api/documents', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        title: title,
                        content: content,
                        doc_type: 'text'
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();
                const docId = result.id;
                log('SUCCESS', `Document created: ${docId}`);
                log('DEBUG', `Status: ${result.status}`);

                // If document is already enriched (sync processing), skip stream and fetch chunks
                if (result.status === 'enriched') {
                    log('INFO', '‚ö° Document already enriched (synchronous processing), fetching chunks...');
                    await fetchAllVisualizationData();
                    return;
                }

                // Try to connect to enrichment stream for async processing
                try {
                    log('INFO', 'üîå Connecting to real-time enrichment stream...');
                    enrichmentStream = new EnrichmentStreamListener(
                        docId,
                        // onChunkEnriched callback
                        (chunk) => {
                            log('INFO', `üìå Chunk ${chunk.chunk_index} enriched in real-time`);
                            addChunkWithAnimation(chunk);
                        },
                        // onProgress callback
                        (progress, total) => {
                            log('DEBUG', `Progress: ${progress}/${total} chunks`);
                            document.getElementById('status-bar').textContent =
                                `Chunks: ${chunkMeshes.size} | Progress: ${progress}/${total}`;
                        },
                        // onComplete callback
                        () => {
                            log('SUCCESS', '‚ú® All chunks enriched!');
                            fitCameraToScene();
                        },
                        // onError callback
                        (error) => {
                            log('WARN', `Stream error (falling back to fetch): ${error.message}`);
                            // Fallback to fetching all chunks
                            fetchAllChunks(docId);
                        }
                    );

                    await enrichmentStream.connect();
                    log('SUCCESS', '‚úÖ Connected to enrichment stream');

                } catch (streamError) {
                    log('WARN', `Stream not available, using polling instead: ${streamError.message}`);
                    fetchAllVisualizationData();
                }

            } catch (error) {
                log('ERROR', `Processing failed: ${error.message}`);
            } finally {
                btn.disabled = false;
            }
        }

        async function fetchAllVisualizationData() {
            log('INFO', 'üì• Fetching full visualization dataset...');
            try {
                const response = await fetch('/api/visualization');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const payload = await response.json();
                const chunks = payload.chunks || [];
                log('SUCCESS', `Fetched ${chunks.length} chunks across ${payload.documents?.length ?? 0} documents`);
                upsertChunks(chunks);
                fitCameraToScene();
            } catch (error) {
                log('ERROR', `Failed to fetch visualization data: ${error.message}`);
            }
        }

        // ===== VISUALIZATION =====
        function upsertChunks(chunks) {
            if (!Array.isArray(chunks)) return;
            let added = 0;
            let updated = 0;

            chunks.forEach((chunk) => {
                try {
                    const parsed = normalizeChunkPayload(chunk);
                    if (!parsed) return;

                    if (chunkMeshes.has(parsed.id)) {
                        updateExistingChunk(parsed);
                        updated += 1;
                    } else {
                        addChunkWithAnimation(parsed);
                        added += 1;
                    }
                } catch (error) {
                    log('ERROR', `Failed to upsert chunk ${chunk?.id ?? 'unknown'}: ${error.message}`);
                }
            });

            log('SUCCESS', `Upserted chunks | added: ${added} updated: ${updated} total: ${chunkMeshes.size}`);
        }

        function normalizeChunkPayload(chunk) {
            if (!chunk || (!chunk.id && !chunk.chunk_id)) return null;

            // Parse embedding if it's a string
            let embedding = chunk.embedding;
            if (typeof embedding === 'string') {
                try {
                    embedding = JSON.parse(embedding);
                } catch (e) {
                    log('WARN', `Could not parse embedding for chunk ${chunk.id ?? chunk.chunk_id}`);
                    embedding = [];
                }
            }

            // Parse coordinates
            let position3d = chunk.position_3d;
            if (typeof position3d === 'string') {
                try {
                    position3d = JSON.parse(position3d);
                } catch (e) {
                    position3d = [0, 0, 0];
                }
            }

            let umapCoordinates = chunk.umap_coordinates;
            if (typeof umapCoordinates === 'string') {
                try {
                    umapCoordinates = JSON.parse(umapCoordinates);
                } catch (e) {
                    umapCoordinates = null;
                }
            }

            const finalCoordinates = Array.isArray(umapCoordinates) && umapCoordinates.length === 3
                ? umapCoordinates
                : position3d;

            return {
                chunk_id: chunk.id || chunk.chunk_id,
                id: chunk.id || chunk.chunk_id,
                embedding: Array.isArray(embedding) ? embedding : [],
                color: chunk.color,
                position_3d: Array.isArray(finalCoordinates) ? finalCoordinates : [0, 0, 0],
                content: chunk.content || '',
                tags: Array.isArray(chunk.tags) ? chunk.tags : [],
                cluster_id: chunk.cluster_id ?? null,
                cluster_label: chunk.cluster_label ?? null,
                cluster_confidence: chunk.cluster_confidence ?? null,
                nearest_chunk_ids: Array.isArray(chunk.nearest_chunk_ids) ? chunk.nearest_chunk_ids : [],
                umap_coordinates: Array.isArray(finalCoordinates) ? finalCoordinates : [0, 0, 0],
                document_id: chunk.document_id || chunk.documentId,
                chunk_index: chunk.chunk_index ?? chunk.chunkIndex ?? 0
            };
        }

        /**
         * Create interesting geometry from embedding vector
         * Uses sophisticated spherical harmonics deformation
         */
        function createGeometryFromEmbedding(embedding) {
            if (!geometryGenerator || !embedding || embedding.length === 0) {
                log('WARN', 'Using fallback sphere');
                return new THREE.SphereGeometry(5, 32, 32);
            }

            // Generate unique geometry from embedding using spherical harmonics
            const geometry = geometryGenerator.generatePlanetaryGeometry(embedding);

            // Scale to appropriate size
            geometry.scale(5, 5, 5);

            return geometry;
        }

        function fitCameraToScene() {
            if (chunkMeshes.size === 0) return;

            const box = new THREE.Box3();
            chunkMeshes.forEach(mesh => box.expandByObject(mesh));

            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 1.5;

            const center = box.getCenter(new THREE.Vector3());
            camera.position.copy(center);
            camera.position.z += cameraZ;

            controls.target.copy(center);
            controls.update();

            log('INFO', `üì∏ Camera fitted to ${chunkMeshes.size} chunks`);
        }

        function updateStatusBar() {
            const chunks = chunkMeshes.size;
            const clusterIds = new Set();
            chunkMeshes.forEach(mesh => {
                const cid = mesh.userData && mesh.userData.clusterId;
                if (cid !== null && cid !== undefined) {
                    clusterIds.add(cid);
                }
            });
            document.getElementById('status-bar').textContent =
                `Chunks: ${chunks} | Clusters: ${clusterIds.size} | Embeddings: ${chunks} | Geometry: ${chunks}`;
        }

        /**
         * Calculate centroid of a set of chunks
         */
        function calculateCentroid(meshArray) {
            if (meshArray.length === 0) {
                return new THREE.Vector3(0, 0, 0);
            }

            const sum = new THREE.Vector3(0, 0, 0);
            meshArray.forEach(mesh => sum.add(mesh.position));
            return sum.divideScalar(meshArray.length);
        }

        /**
         * Update rotation center based on selection hierarchy:
         * 1. Chunk selected ‚Üí center on chunk
         * 2. Document selected ‚Üí center on document's chunks
         * 3. Nebula selected ‚Üí center on nebula's chunks
         * 4. Nothing selected ‚Üí center on all chunks (centroid)
         */
        function updateRotationCenter() {
            if (selectedMesh) {
                // Chunk selected: rotate around that chunk
                rotationCenter.copy(selectedMesh.position);
                log('DEBUG', `üéØ Rotation center: chunk (${rotationCenter.x.toFixed(1)}, ${rotationCenter.y.toFixed(1)}, ${rotationCenter.z.toFixed(1)})`);
            } else if (selectedDocumentId) {
                // Document selected: rotate around centroid of all chunks in document
                const docChunks = Array.from(chunkMeshes.values()).filter(
                    mesh => mesh.userData.documentId === selectedDocumentId
                );
                if (docChunks.length > 0) {
                    rotationCenter.copy(calculateCentroid(docChunks));
                    log('DEBUG', `üìÑ Rotation center: document centroid (${docChunks.length} chunks)`);
                }
            } else if (selectedNebulaId) {
                // Nebula selected: rotate around centroid of all chunks in nebula
                const nebulaChunks = Array.from(chunkMeshes.values()).filter(
                    mesh => mesh.userData.nebulaId === selectedNebulaId
                );
                if (nebulaChunks.length > 0) {
                    rotationCenter.copy(calculateCentroid(nebulaChunks));
                    log('DEBUG', `‚òÅÔ∏è Rotation center: nebula centroid (${nebulaChunks.length} chunks)`);
                }
            } else {
                // Nothing selected: rotate around centroid of ALL chunks
                const allChunks = Array.from(chunkMeshes.values());
                if (allChunks.length > 0) {
                    rotationCenter.copy(calculateCentroid(allChunks));
                    log('DEBUG', `üåå Rotation center: cosmos centroid (${allChunks.length} chunks)`);
                }
            }
        }

        /**
         * Add a chunk to the visualization with animated appearance
         * @param {Object} chunk - Chunk object from enrichment stream
         */
        function addChunkWithAnimation(chunk) {
            if (!chunk || !chunk.id) {
                log('WARN', 'Chunk missing ID');
                return;
            }

            if (chunkMeshes.has(chunk.id)) {
                updateExistingChunk(chunk);
                return;
            }

            try {
                const geometry = (chunk.embedding && chunk.embedding.length > 0)
                    ? createGeometryFromEmbedding(chunk.embedding)
                    : new THREE.SphereGeometry(5, 32, 32);

                let color = 0x748ffc;
                if (chunk.color && typeof chunk.color === 'string' && chunk.color.startsWith('#')) {
                    color = parseInt(chunk.color.slice(1), 16);
                }

                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.2,
                    roughness: 0.7,
                    metalness: 0.2
                });

                const mesh = new THREE.Mesh(geometry, material);
                const finalPos = chunk.position_3d && chunk.position_3d.length === 3 ? chunk.position_3d : [0, 0, 0];
                mesh.position.set(finalPos[0], finalPos[1], finalPos[2]);

                mesh.userData = buildChunkUserData(chunk);

                mesh.scale.set(0.1, 0.1, 0.1);
                material.transparent = true;
                material.opacity = 0;

                scene.add(mesh);
                chunkMeshes.set(chunk.id, mesh);

                animateChunkIntoPlace(mesh, material, finalPos);

                log('DEBUG', `Added chunk ${chunk.id} with animation`);
                updateStatusBar();

            } catch (error) {
                log('ERROR', `Failed to add chunk: ${error.message}`);
            }
        }

        function updateExistingChunk(chunk) {
            const mesh = chunkMeshes.get(chunk.id);
            if (!mesh) return;

            // Update geometry if embedding changed
            if (chunk.embedding && chunk.embedding.length > 0) {
                const newGeometry = createGeometryFromEmbedding(chunk.embedding);
                mesh.geometry.dispose();
                mesh.geometry = newGeometry;
            }

            // Update color
            if (chunk.color && typeof chunk.color === 'string' && chunk.color.startsWith('#')) {
                const parsed = parseInt(chunk.color.slice(1), 16);
                mesh.material.color.setHex(parsed);
                mesh.material.emissive.setHex(parsed);
            }

            if (chunk.position_3d && chunk.position_3d.length === 3) {
                mesh.position.set(chunk.position_3d[0], chunk.position_3d[1], chunk.position_3d[2]);
            }

            mesh.userData = {
                ...mesh.userData,
                ...buildChunkUserData(chunk),
            };
        }

        function buildChunkUserData(chunk) {
            return {
                chunkId: chunk.id,
                documentId: chunk.document_id || chunk.documentId,
                nebulaId: chunk.nebula_id || chunk.nebulaId,
                content: chunk.content || '',
                embedding: chunk.embedding || [],
                tags: chunk.tags || [],
                clusterId: chunk.cluster_id ?? null,
                clusterLabel: chunk.cluster_label ?? null,
                clusterConfidence: chunk.cluster_confidence ?? null,
                nearestChunkIds: Array.isArray(chunk.nearest_chunk_ids) ? chunk.nearest_chunk_ids : [],
                umapCoordinates: Array.isArray(chunk.umap_coordinates) ? chunk.umap_coordinates : chunk.position_3d || [],
                chunkIndex: chunk.chunk_index ?? 0,
            };
        }

        function animateChunkIntoPlace(mesh, material, finalPos) {
            const startScale = new THREE.Vector3(0.1, 0.1, 0.1);
            const endScale = new THREE.Vector3(1, 1, 1);
            const startPos = new THREE.Vector3(0, 0, 0);
            const endPos = new THREE.Vector3(finalPos[0], finalPos[1], finalPos[2]);

            const startTime = performance.now();
            const duration = 800;

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3);

                mesh.scale.lerpVectors(startScale, endScale, easeProgress);
                mesh.position.lerpVectors(startPos, endPos, easeProgress);
                material.opacity = easeProgress;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    material.transparent = false;
                }
            }

            requestAnimationFrame(animate);
        }

        /**
         * Deselect all selections
         */
        function deselectAll() {
            if (selectedMesh) {
                selectedMesh.material.emissiveIntensity = 0.2;
                selectedMesh = null;
            }
            selectedDocumentId = null;
            selectedNebulaId = null;
            log('INFO', '‚óá Deselected all');
            updateRotationCenter();
        }

        /**
         * Focus on a specific chunk
         */
        function focusOnChunk(mesh) {
            // Deselect previous mesh
            if (selectedMesh) {
                selectedMesh.material.emissiveIntensity = 0.2;
            }

            // Select new chunk (also selects its document)
            selectedMesh = mesh;
            selectedDocumentId = mesh.userData.documentId;
            selectedNebulaId = mesh.userData.nebulaId;
            mesh.material.emissiveIntensity = 0.8;

            const chunkId = mesh.userData.chunkId;
            const docId = mesh.userData.documentId;
            const content = mesh.userData.content;

            log('INFO', `üìå Selected chunk: ${chunkId}`);
            if (docId) log('DEBUG', `  Document: ${docId}`);
            const clusterId = mesh.userData.clusterId;
            if (clusterId !== null && clusterId !== undefined) {
                const label = mesh.userData.clusterLabel || `Cluster ${clusterId}`;
                const confidence = mesh.userData.clusterConfidence;
                const confidenceText = typeof confidence === 'number'
                    ? confidence.toFixed(2)
                    : 'n/a';
                log('DEBUG', `Cluster: ${clusterId} (${label}) | confidence ${confidenceText}`);
            } else {
                log('DEBUG', 'Cluster: noise / unassigned');
            }
            const nearestIds = mesh.userData.nearestChunkIds || [];
            if (nearestIds.length > 0) {
                log('DEBUG', `Nearest chunks: ${nearestIds.slice(0, 5).join(', ')}`);
            }
            log('DEBUG', `Content: ${content.substring(0, 80)}...`);

            // Animate camera to focus on chunk
            const targetPos = mesh.position.clone();
            const distance = 25; // How close to zoom
            const direction = targetPos.clone().normalize();
            const cameraTarget = targetPos.clone().add(direction.multiplyScalar(distance));

            // Smooth animation to new position
            const startPos = camera.position.clone();
            const startTime = Date.now();
            const duration = 600; // ms

            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = progress < 0.5
                    ? 2 * progress * progress
                    : -1 + (4 - 2 * progress) * progress;

                camera.position.lerpVectors(startPos, cameraTarget, easeProgress);
                camera.lookAt(targetPos);

                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }

            animateCamera();
        }

        /**
         * Focus on a document (all its chunks)
         */
        function focusOnDocument(documentId) {
            deselectAll();
            selectedDocumentId = documentId;

            // Find and highlight all chunks in document
            const docChunks = Array.from(chunkMeshes.values()).filter(
                mesh => mesh.userData.documentId === documentId
            );

            log('INFO', `üìÑ Selected document: ${documentId} (${docChunks.length} chunks)`);

            // Animate camera to document centroid
            const centroid = calculateCentroid(docChunks);
            const distance = 50;
            const direction = centroid.clone().normalize();
            const cameraTarget = centroid.clone().add(direction.multiplyScalar(distance));

            const startPos = camera.position.clone();
            const startTime = performance.now();
            const duration = 600;

            function animateCamera(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = progress < 0.5
                    ? 2 * progress * progress
                    : -1 + (4 - 2 * progress) * progress;

                camera.position.lerpVectors(startPos, cameraTarget, easeProgress);
                camera.lookAt(centroid);

                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }

            requestAnimationFrame(animateCamera);
            updateRotationCenter();
        }

        /**
         * Focus on a nebula (all its documents)
         */
        function focusOnNebula(nebulaId) {
            deselectAll();
            selectedNebulaId = nebulaId;

            // Find and highlight all chunks in nebula
            const nebulaChunks = Array.from(chunkMeshes.values()).filter(
                mesh => mesh.userData.nebulaId === nebulaId
            );

            log('INFO', `‚òÅÔ∏è Selected nebula: ${nebulaId} (${nebulaChunks.length} chunks)`);

            // Animate camera to nebula centroid
            const centroid = calculateCentroid(nebulaChunks);
            const distance = 80;
            const direction = centroid.clone().normalize();
            const cameraTarget = centroid.clone().add(direction.multiplyScalar(distance));

            const startPos = camera.position.clone();
            const startTime = performance.now();
            const duration = 600;

            function animateCamera(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = progress < 0.5
                    ? 2 * progress * progress
                    : -1 + (4 - 2 * progress) * progress;

                camera.position.lerpVectors(startPos, cameraTarget, easeProgress);
                camera.lookAt(centroid);

                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }

            requestAnimationFrame(animateCamera);
            updateRotationCenter();
        }

        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', () => {
            log('INFO', 'üé¨ Initializing Headspace Debug Mode');
            initScene();
            log('SUCCESS', 'Ready! Enter a document and click "Process & Visualize"');

            // Initial dataset load on page open
            fetchAllVisualizationData();

            document.getElementById('process-btn').addEventListener('click', processDocument);
            document.getElementById('document-content').addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    processDocument();
                }
            });

            // Demo content
            document.getElementById('document-title').value = 'Quantum Computing';
            document.getElementById('document-content').value =
                `Quantum computing represents a fundamental shift in computation. It leverages quantum mechanical phenomena like superposition and entanglement.

Quantum bits or qubits are the basic unit. Unlike classical bits which are 0 or 1, qubits can exist in a superposition of both states simultaneously.

Quantum entanglement allows pairs of qubits to be correlated in ways that have no classical equivalent. This creates powerful computational capabilities.

Quantum gates are operations applied to qubits. They manipulate the quantum states and create interference patterns that amplify correct answers.

The measurement problem in quantum mechanics means that measuring a quantum system collapses its state to a definite value.`;
        });
    </script>
</body>
</html>
