<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Headspace - Debug Mode</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0e27;
            color: #00ff00;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
        }

        #canvas-container {
            flex: 1;
            position: relative;
        }

        #side-panel {
            width: 400px;
            background: #001a33;
            border-left: 2px solid #00ff00;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #input-section {
            padding: 20px;
            border-bottom: 2px solid #00ff00;
        }

        #input-section h2 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #00ff00;
        }

        #document-title {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background: #0a0e27;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: monospace;
            font-size: 12px;
        }

        #document-content {
            width: 100%;
            height: 120px;
            padding: 8px;
            margin-bottom: 10px;
            background: #0a0e27;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: monospace;
            font-size: 12px;
            resize: none;
        }

        #process-btn {
            width: 100%;
            padding: 10px;
            background: #00ff00;
            color: #001a33;
            border: none;
            font-weight: bold;
            cursor: pointer;
            font-family: monospace;
            transition: all 0.2s;
        }

        #process-btn:hover {
            background: #00dd00;
            transform: scale(1.02);
        }

        #process-btn:disabled {
            background: #666;
            cursor: not-allowed;
            color: #333;
        }

        #console {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            font-size: 11px;
            line-height: 1.4;
            border-top: 2px solid #00ff00;
        }

        .log-line {
            margin-bottom: 4px;
            padding: 2px 5px;
        }

        .log-info {
            color: #00ff00;
        }

        .log-debug {
            color: #00aa00;
        }

        .log-warn {
            color: #ffaa00;
        }

        .log-error {
            color: #ff0000;
        }

        .log-success {
            color: #00ffaa;
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .status-bar {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            padding: 10px;
            border: 1px solid #00ff00;
            font-size: 12px;
            font-family: monospace;
            border-radius: 3px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div class="status-bar" id="status-bar">
                Chunks: 0 | Embeddings: 0 | Geometry: 0
            </div>
        </div>
        <div id="side-panel">
            <div id="input-section">
                <h2>ðŸ“„ Document Input</h2>
                <input
                    type="text"
                    id="document-title"
                    placeholder="Document title..."
                    value="My Document"
                >
                <textarea
                    id="document-content"
                    placeholder="Paste your document content here...&#10;&#10;Separate paragraphs with blank lines."
                ></textarea>
                <button id="process-btn">Process & Visualize</button>
            </div>
            <div id="console"></div>
        </div>
    </div>

    <script>
        // ===== LOGGING SYSTEM =====
        const consoleEl = document.getElementById('console');
        const logLevels = {
            DEBUG: 'log-debug',
            INFO: 'log-info',
            WARN: 'log-warn',
            ERROR: 'log-error',
            SUCCESS: 'log-success'
        };

        function log(level, message) {
            const timestamp = new Date().toLocaleTimeString();
            const className = logLevels[level] || 'log-info';
            const emoji = {
                DEBUG: 'ðŸ”',
                INFO: 'â„¹ï¸',
                WARN: 'âš ï¸',
                ERROR: 'âŒ',
                SUCCESS: 'âœ…'
            }[level] || 'â€¢';

            const line = document.createElement('div');
            line.className = `log-line ${className}`;
            line.textContent = `[${timestamp}] ${emoji} ${message}`;

            consoleEl.appendChild(line);
            consoleEl.scrollTop = consoleEl.scrollHeight;

            console.log(`[${level}] ${message}`);
        }

        // ===== THREE.JS SETUP =====
        let scene, camera, renderer, controls;
        let chunkMeshes = new Map();

        function initScene() {
            const canvas = document.getElementById('canvas');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x001a33);
            scene.fog = new THREE.Fog(0x001a33, 500, 2000);

            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 10000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Simple camera controls (mouse drag to rotate)
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    // Rotate camera around scene center
                    const radius = 100;
                    const phi = Math.atan2(camera.position.z, camera.position.x) + deltaX * 0.01;
                    const theta = Math.acos(camera.position.y / radius) + deltaY * 0.01;

                    camera.position.x = radius * Math.sin(theta) * Math.cos(phi);
                    camera.position.y = radius * Math.cos(theta);
                    camera.position.z = radius * Math.sin(theta) * Math.sin(phi);
                    camera.lookAt(0, 0, 0);

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoom = e.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(zoom);
            }, false);

            controls = { update: () => {} }; // Dummy controls object

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(100, 100, 100);
            scene.add(pointLight);

            // Starfield
            const starGeom = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 1000; i++) {
                vertices.push(
                    (Math.random() - 0.5) * 2000,
                    (Math.random() - 0.5) * 2000,
                    (Math.random() - 0.5) * 2000
                );
            }
            starGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 2 });
            const stars = new THREE.Points(starGeom, starMat);
            scene.add(stars);

            log('INFO', 'Three.js scene initialized');

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update();

                chunkMeshes.forEach(mesh => {
                    mesh.rotation.x += 0.0002;
                    mesh.rotation.y += 0.0003;
                });

                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            });
        }

        // ===== API CALLS =====
        async function processDocument() {
            const title = document.getElementById('document-title').value;
            const content = document.getElementById('document-content').value;
            const btn = document.getElementById('process-btn');

            if (!title || !content) {
                log('WARN', 'Please enter title and content');
                return;
            }

            btn.disabled = true;
            log('INFO', `Starting document processing: "${title}"`);
            log('DEBUG', `Content length: ${content.length} chars`);

            try {
                // Clear existing meshes
                chunkMeshes.forEach(mesh => {
                    scene.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                });
                chunkMeshes.clear();

                log('INFO', 'ðŸš€ Sending to API...');
                const response = await fetch('/api/documents', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        title: title,
                        content: content,
                        doc_type: 'text'
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();
                log('SUCCESS', `Document created: ${result.id}`);
                log('DEBUG', `Status: ${result.status}`);

                // Fetch the document with chunks
                log('INFO', 'ðŸ“¥ Fetching chunks...');
                const docResponse = await fetch(`/api/documents/${result.id}`);
                const doc = await docResponse.json();

                log('SUCCESS', `Got ${doc.chunks.length} chunks`);

                // Visualize chunks
                visualizeChunks(doc.chunks);
                fitCameraToScene();

            } catch (error) {
                log('ERROR', `Processing failed: ${error.message}`);
            } finally {
                btn.disabled = false;
            }
        }

        // ===== VISUALIZATION =====
        function visualizeChunks(chunks) {
            log('INFO', 'ðŸŽ¨ Creating geometry...');

            chunks.forEach((chunk, idx) => {
                try {
                    // Parse position
                    let pos = [0, 0, 0];
                    if (chunk.position_3d) {
                        if (Array.isArray(chunk.position_3d)) {
                            pos = chunk.position_3d;
                        } else if (typeof chunk.position_3d === 'string') {
                            try {
                                pos = JSON.parse(chunk.position_3d);
                            } catch (e) {
                                log('WARN', `Could not parse position for chunk ${idx}`);
                            }
                        }
                    }

                    // Parse color
                    let color = 0x748ffc;
                    if (chunk.color && chunk.color.startsWith('#')) {
                        color = parseInt(chunk.color.slice(1), 16);
                    }

                    // Parse embedding for geometry calculation
                    let embedding = chunk.embedding || [];
                    if (typeof embedding === 'string') {
                        try {
                            embedding = JSON.parse(embedding);
                        } catch (e) {
                            embedding = [];
                        }
                    }

                    // Create geometry based on embedding
                    let geometry;
                    if (embedding && embedding.length > 0) {
                        // Use embedding to determine geometry
                        geometry = createGeometryFromEmbedding(embedding);
                        log('DEBUG', `Chunk ${idx}: Geometry from embedding (dim=${embedding.length})`);
                    } else {
                        // Fallback to sphere
                        geometry = new THREE.SphereGeometry(5, 32, 32);
                        log('DEBUG', `Chunk ${idx}: Fallback sphere (no embedding)`);
                    }

                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.2,
                        roughness: 0.7,
                        metalness: 0.2
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(pos[0], pos[1], pos[2]);
                    mesh.userData = {
                        chunkId: chunk.id,
                        content: chunk.content,
                        embedding: embedding
                    };

                    scene.add(mesh);
                    chunkMeshes.set(chunk.id, mesh);

                } catch (error) {
                    log('ERROR', `Failed to create mesh for chunk ${idx}: ${error.message}`);
                }
            });

            log('SUCCESS', `âœ¨ Created ${chunkMeshes.size} geometries`);
            updateStatusBar();
        }

        /**
         * Create interesting geometry from embedding vector
         * This is the key math that makes the shapes!
         */
        function createGeometryFromEmbedding(embedding) {
            const dim = embedding.length;
            const mag = Math.sqrt(embedding.reduce((sum, x) => sum + x * x, 0));
            const normalized = embedding.map(x => x / (mag || 1));

            // Use embedding statistics to determine shape
            const mean = embedding.reduce((a, b) => a + b) / dim;
            const variance = embedding.reduce((sum, x) => sum + (x - mean) ** 2, 0) / dim;
            const skewness = normalized.slice(0, 3).reduce((a, b) => a + b ** 3, 0);

            // Different shapes based on embedding characteristics
            if (variance < 0.1) {
                // Low variance = smooth sphere
                return new THREE.SphereGeometry(5, 32, 32);
            } else if (variance < 0.3) {
                // Medium variance = icosahedron
                return new THREE.IcosahedronGeometry(5, 3);
            } else if (variance < 0.6) {
                // Higher variance = cube
                return new THREE.BoxGeometry(8, 8, 8, 3, 3, 3);
            } else if (Math.abs(skewness) > 0.5) {
                // Skewed = torus
                return new THREE.TorusGeometry(5, 2, 16, 100);
            } else {
                // Default = octahedron
                return new THREE.OctahedronGeometry(5, 2);
            }
        }

        function fitCameraToScene() {
            if (chunkMeshes.size === 0) return;

            const box = new THREE.Box3();
            chunkMeshes.forEach(mesh => box.expandByObject(mesh));

            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 1.5;

            const center = box.getCenter(new THREE.Vector3());
            camera.position.copy(center);
            camera.position.z += cameraZ;

            controls.target.copy(center);
            controls.update();

            log('INFO', `ðŸ“¸ Camera fitted to ${chunkMeshes.size} chunks`);
        }

        function updateStatusBar() {
            const chunks = chunkMeshes.size;
            document.getElementById('status-bar').textContent =
                `Chunks: ${chunks} | Embeddings: ${chunks} | Geometry: ${chunks}`;
        }

        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', () => {
            log('INFO', 'ðŸŽ¬ Initializing Headspace Debug Mode');
            initScene();
            log('SUCCESS', 'Ready! Enter a document and click "Process & Visualize"');

            document.getElementById('process-btn').addEventListener('click', processDocument);
            document.getElementById('document-content').addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    processDocument();
                }
            });

            // Demo content
            document.getElementById('document-title').value = 'Quantum Computing';
            document.getElementById('document-content').value =
                `Quantum computing represents a fundamental shift in computation. It leverages quantum mechanical phenomena like superposition and entanglement.

Quantum bits or qubits are the basic unit. Unlike classical bits which are 0 or 1, qubits can exist in a superposition of both states simultaneously.

Quantum entanglement allows pairs of qubits to be correlated in ways that have no classical equivalent. This creates powerful computational capabilities.

Quantum gates are operations applied to qubits. They manipulate the quantum states and create interference patterns that amplify correct answers.

The measurement problem in quantum mechanics means that measuring a quantum system collapses its state to a definite value.`;
        });
    </script>
</body>
</html>
