<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Headspace - Debug Mode</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="js/procedural-geometry.js"></script>
    <script src="js/enrichment-stream.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0e27;
            color: #00ff00;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
        }

        #canvas-container {
            flex: 1;
            position: relative;
        }

        #side-panel {
            width: 400px;
            background: #001a33;
            border-left: 2px solid #00ff00;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #input-section {
            padding: 20px;
            border-bottom: 2px solid #00ff00;
        }

        #input-section h2 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #00ff00;
        }

        #document-title {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background: #0a0e27;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: monospace;
            font-size: 12px;
        }

        #document-content {
            width: 100%;
            height: 120px;
            padding: 8px;
            margin-bottom: 10px;
            background: #0a0e27;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: monospace;
            font-size: 12px;
            resize: none;
        }

        #process-btn {
            width: 100%;
            padding: 10px;
            background: #00ff00;
            color: #001a33;
            border: none;
            font-weight: bold;
            cursor: pointer;
            font-family: monospace;
            transition: all 0.2s;
        }

        #process-btn:hover {
            background: #00dd00;
            transform: scale(1.02);
        }

        #process-btn:disabled {
            background: #666;
            cursor: not-allowed;
            color: #333;
        }

        #console {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            font-size: 11px;
            line-height: 1.4;
            border-top: 2px solid #00ff00;
        }

        .log-line {
            margin-bottom: 4px;
            padding: 2px 5px;
        }

        .log-info {
            color: #00ff00;
        }

        .log-debug {
            color: #00aa00;
        }

        .log-warn {
            color: #ffaa00;
        }

        .log-error {
            color: #ff0000;
        }

        .log-success {
            color: #00ffaa;
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .status-bar {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            padding: 10px;
            border: 1px solid #00ff00;
            font-size: 12px;
            font-family: monospace;
            border-radius: 3px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div class="status-bar" id="status-bar">
                Chunks: 0 | Embeddings: 0 | Geometry: 0
            </div>
        </div>
        <div id="side-panel">
            <div id="input-section">
                <h2>üìÑ Document Input</h2>
                <input
                    type="text"
                    id="document-title"
                    placeholder="Document title..."
                    value="My Document"
                >
                <textarea
                    id="document-content"
                    placeholder="Paste your document content here...&#10;&#10;Separate paragraphs with blank lines."
                ></textarea>
                <button id="process-btn">Process & Visualize</button>
            </div>
            <div id="console"></div>
        </div>
    </div>

    <script>
        // ===== LOGGING SYSTEM =====
        const consoleEl = document.getElementById('console');
        const logLevels = {
            DEBUG: 'log-debug',
            INFO: 'log-info',
            WARN: 'log-warn',
            ERROR: 'log-error',
            SUCCESS: 'log-success'
        };

        function log(level, message) {
            const timestamp = new Date().toLocaleTimeString();
            const className = logLevels[level] || 'log-info';
            const emoji = {
                DEBUG: 'üîç',
                INFO: '‚ÑπÔ∏è',
                WARN: '‚ö†Ô∏è',
                ERROR: '‚ùå',
                SUCCESS: '‚úÖ'
            }[level] || '‚Ä¢';

            const line = document.createElement('div');
            line.className = `log-line ${className}`;
            line.textContent = `[${timestamp}] ${emoji} ${message}`;

            consoleEl.appendChild(line);
            consoleEl.scrollTop = consoleEl.scrollHeight;

            console.log(`[${level}] ${message}`);
        }

        // ===== THREE.JS SETUP =====
        let scene, camera, renderer, controls;
        let chunkMeshes = new Map();
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let selectedMesh = null;
        let selectedDocumentId = null;
        let selectedNebulaId = null;
        let geometryGenerator = null;

        function initScene() {
            const canvas = document.getElementById('canvas');

            // Initialize procedural geometry generator
            geometryGenerator = new ProceduralGeometryGenerator();
            log('INFO', 'Procedural geometry generator initialized');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x001a33);
            scene.fog = new THREE.Fog(0x001a33, 500, 2000);

            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 10000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Simple camera controls (mouse drag to rotate)
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let rotationCenter = new THREE.Vector3(0, 0, 0); // Center of rotation

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
                // Update rotation center based on selection hierarchy
                updateRotationCenter();
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    // Rotate camera around rotation center (selected chunk or origin)
                    const relativePos = camera.position.clone().sub(rotationCenter);
                    const radius = relativePos.length();

                    const phi = Math.atan2(relativePos.z, relativePos.x) + deltaX * 0.01;
                    const theta = Math.acos(relativePos.y / (radius || 1)) + deltaY * 0.01;

                    relativePos.x = radius * Math.sin(theta) * Math.cos(phi);
                    relativePos.y = radius * Math.cos(theta);
                    relativePos.z = radius * Math.sin(theta) * Math.sin(phi);

                    camera.position.copy(relativePos.add(rotationCenter));
                    camera.lookAt(rotationCenter);

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoom = e.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(zoom);
            }, false);

            controls = {
                target: new THREE.Vector3(0, 0, 0),
                update: () => {},
                dispose: () => {}
            }; // Dummy controls object

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(100, 100, 100);
            scene.add(pointLight);

            // Starfield
            const starGeom = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 1000; i++) {
                vertices.push(
                    (Math.random() - 0.5) * 2000,
                    (Math.random() - 0.5) * 2000,
                    (Math.random() - 0.5) * 2000
                );
            }
            starGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 2 });
            const stars = new THREE.Points(starGeom, starMat);
            scene.add(stars);

            log('INFO', 'Three.js scene initialized');

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update();

                chunkMeshes.forEach(mesh => {
                    mesh.rotation.x += 0.0002;
                    mesh.rotation.y += 0.0003;
                });

                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            });

            // Click handler for chunk selection/deselection
            canvas.addEventListener('click', (event) => {
                if (event.button !== 0 || event.ctrlKey || event.metaKey) return; // Only left click, not drag

                const rect = canvas.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(Array.from(chunkMeshes.values()));

                if (intersects.length > 0) {
                    const mesh = intersects[0].object;
                    focusOnChunk(mesh);
                } else {
                    // Clicked empty space - deselect all
                    deselectAll();
                }
            });
        }

        // ===== API CALLS & STREAMING =====
        let enrichmentStream = null;

        async function processDocument() {
            const title = document.getElementById('document-title').value;
            const content = document.getElementById('document-content').value;
            const btn = document.getElementById('process-btn');

            if (!title || !content) {
                log('WARN', 'Please enter title and content');
                return;
            }

            btn.disabled = true;
            log('INFO', `Starting document processing: "${title}"`);
            log('DEBUG', `Content length: ${content.length} chars`);

            try {
                // Clear existing meshes
                chunkMeshes.forEach(mesh => {
                    scene.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                });
                chunkMeshes.clear();

                log('INFO', 'üöÄ Sending to API...');
                const response = await fetch('/api/documents', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        title: title,
                        content: content,
                        doc_type: 'text'
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();
                const docId = result.id;
                log('SUCCESS', `Document created: ${docId}`);
                log('DEBUG', `Status: ${result.status}`);

                // If document is already enriched (sync processing), skip stream and fetch chunks
                if (result.status === 'enriched') {
                    log('INFO', '‚ö° Document already enriched (synchronous processing), fetching chunks...');
                    await fetchAllChunks(docId);
                    return;
                }

                // Try to connect to enrichment stream for async processing
                try {
                    log('INFO', 'üîå Connecting to real-time enrichment stream...');
                    enrichmentStream = new EnrichmentStreamListener(
                        docId,
                        // onChunkEnriched callback
                        (chunk) => {
                            log('INFO', `üìå Chunk ${chunk.chunk_index} enriched in real-time`);
                            addChunkWithAnimation(chunk);
                        },
                        // onProgress callback
                        (progress, total) => {
                            log('DEBUG', `Progress: ${progress}/${total} chunks`);
                            document.getElementById('status-bar').textContent =
                                `Chunks: ${chunkMeshes.size} | Progress: ${progress}/${total}`;
                        },
                        // onComplete callback
                        () => {
                            log('SUCCESS', '‚ú® All chunks enriched!');
                            fitCameraToScene();
                        },
                        // onError callback
                        (error) => {
                            log('WARN', `Stream error (falling back to fetch): ${error.message}`);
                            // Fallback to fetching all chunks
                            fetchAllChunks(docId);
                        }
                    );

                    await enrichmentStream.connect();
                    log('SUCCESS', '‚úÖ Connected to enrichment stream');

                } catch (streamError) {
                    log('WARN', `Stream not available, using polling instead: ${streamError.message}`);
                    fetchAllChunks(docId);
                }

            } catch (error) {
                log('ERROR', `Processing failed: ${error.message}`);
            } finally {
                btn.disabled = false;
            }
        }

        async function fetchAllChunks(docId) {
            log('INFO', 'üì• Fetching all chunks...');
            try {
                const docResponse = await fetch(`/api/documents/${docId}`);
                const doc = await docResponse.json();
                log('SUCCESS', `Got ${doc.chunks.length} chunks`);
                visualizeChunks(doc.chunks);

                // Fit camera after all animations complete
                const maxStagger = (doc.chunks.length - 1) * 200 + 800; // Last chunk stagger + animation duration
                setTimeout(() => {
                    fitCameraToScene();
                }, maxStagger);
            } catch (error) {
                log('ERROR', `Failed to fetch chunks: ${error.message}`);
            }
        }

        // ===== VISUALIZATION =====
        function visualizeChunks(chunks) {
            log('INFO', 'üé® Creating geometry with animation...');

            // Stagger chunk animations for visual effect
            chunks.forEach((chunk, idx) => {
                setTimeout(() => {
                    try {
                        // Parse embedding if it's a string
                        let embedding = chunk.embedding;
                        if (typeof embedding === 'string') {
                            try {
                                embedding = JSON.parse(embedding);
                            } catch (e) {
                                log('WARN', `Could not parse embedding for chunk ${chunk.id}`);
                                embedding = [];
                            }
                        }

                        // Parse position_3d if it's a string
                        let position_3d = chunk.position_3d;
                        if (typeof position_3d === 'string') {
                            try {
                                position_3d = JSON.parse(position_3d);
                            } catch (e) {
                                position_3d = [0, 0, 0];
                            }
                        }

                        // Normalize chunk format for addChunkWithAnimation
                        const normalizedChunk = {
                            chunk_id: chunk.id,
                            id: chunk.id,
                            embedding: embedding,
                            color: chunk.color,
                            position_3d: position_3d,
                            content: chunk.content,
                            tags: chunk.tags
                        };

                        addChunkWithAnimation(normalizedChunk);
                    } catch (error) {
                        log('ERROR', `Failed to visualize chunk ${idx}: ${error.message}`);
                    }
                }, idx * 200); // 200ms stagger between chunks
            });

            log('SUCCESS', `‚ú® Creating ${chunks.length} geometries (staggered)`);
        }

        /**
         * Create interesting geometry from embedding vector
         * Uses sophisticated spherical harmonics deformation
         */
        function createGeometryFromEmbedding(embedding) {
            if (!geometryGenerator || !embedding || embedding.length === 0) {
                log('WARN', 'Using fallback sphere');
                return new THREE.SphereGeometry(5, 32, 32);
            }

            // Generate unique geometry from embedding using spherical harmonics
            const geometry = geometryGenerator.generatePlanetaryGeometry(embedding);

            // Scale to appropriate size
            geometry.scale(5, 5, 5);

            return geometry;
        }

        function fitCameraToScene() {
            if (chunkMeshes.size === 0) return;

            const box = new THREE.Box3();
            chunkMeshes.forEach(mesh => box.expandByObject(mesh));

            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 1.5;

            const center = box.getCenter(new THREE.Vector3());
            camera.position.copy(center);
            camera.position.z += cameraZ;

            controls.target.copy(center);
            controls.update();

            log('INFO', `üì∏ Camera fitted to ${chunkMeshes.size} chunks`);
        }

        function updateStatusBar() {
            const chunks = chunkMeshes.size;
            document.getElementById('status-bar').textContent =
                `Chunks: ${chunks} | Embeddings: ${chunks} | Geometry: ${chunks}`;
        }

        /**
         * Calculate centroid of a set of chunks
         */
        function calculateCentroid(meshArray) {
            if (meshArray.length === 0) {
                return new THREE.Vector3(0, 0, 0);
            }

            const sum = new THREE.Vector3(0, 0, 0);
            meshArray.forEach(mesh => sum.add(mesh.position));
            return sum.divideScalar(meshArray.length);
        }

        /**
         * Update rotation center based on selection hierarchy:
         * 1. Chunk selected ‚Üí center on chunk
         * 2. Document selected ‚Üí center on document's chunks
         * 3. Nebula selected ‚Üí center on nebula's chunks
         * 4. Nothing selected ‚Üí center on all chunks (centroid)
         */
        function updateRotationCenter() {
            if (selectedMesh) {
                // Chunk selected: rotate around that chunk
                rotationCenter.copy(selectedMesh.position);
                log('DEBUG', `üéØ Rotation center: chunk (${rotationCenter.x.toFixed(1)}, ${rotationCenter.y.toFixed(1)}, ${rotationCenter.z.toFixed(1)})`);
            } else if (selectedDocumentId) {
                // Document selected: rotate around centroid of all chunks in document
                const docChunks = Array.from(chunkMeshes.values()).filter(
                    mesh => mesh.userData.documentId === selectedDocumentId
                );
                if (docChunks.length > 0) {
                    rotationCenter.copy(calculateCentroid(docChunks));
                    log('DEBUG', `üìÑ Rotation center: document centroid (${docChunks.length} chunks)`);
                }
            } else if (selectedNebulaId) {
                // Nebula selected: rotate around centroid of all chunks in nebula
                const nebulaChunks = Array.from(chunkMeshes.values()).filter(
                    mesh => mesh.userData.nebulaId === selectedNebulaId
                );
                if (nebulaChunks.length > 0) {
                    rotationCenter.copy(calculateCentroid(nebulaChunks));
                    log('DEBUG', `‚òÅÔ∏è Rotation center: nebula centroid (${nebulaChunks.length} chunks)`);
                }
            } else {
                // Nothing selected: rotate around centroid of ALL chunks
                const allChunks = Array.from(chunkMeshes.values());
                if (allChunks.length > 0) {
                    rotationCenter.copy(calculateCentroid(allChunks));
                    log('DEBUG', `üåå Rotation center: cosmos centroid (${allChunks.length} chunks)`);
                }
            }
        }

        /**
         * Add a chunk to the visualization with animated appearance
         * @param {Object} chunk - Chunk object from enrichment stream
         */
        function addChunkWithAnimation(chunk) {
            if (!chunk.chunk_id && !chunk.id) {
                log('WARN', 'Chunk missing ID');
                return;
            }

            try {
                const chunkId = chunk.chunk_id || chunk.id;

                // Create geometry from embedding
                let geometry;
                if (chunk.embedding && chunk.embedding.length > 0) {
                    geometry = createGeometryFromEmbedding(chunk.embedding);
                } else {
                    log('WARN', `Chunk ${chunkId} has no embedding, using sphere`);
                    geometry = new THREE.SphereGeometry(5, 32, 32);
                }

                // Parse color
                let color = 0x748ffc; // Default purple
                if (chunk.color && chunk.color.startsWith('#')) {
                    color = parseInt(chunk.color.slice(1), 16);
                }

                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.2,
                    roughness: 0.7,
                    metalness: 0.2
                });

                const mesh = new THREE.Mesh(geometry, material);

                // Set position from 3D coordinates
                let finalPos = [0, 0, 0];
                if (chunk.position_3d && Array.isArray(chunk.position_3d) && chunk.position_3d.length === 3) {
                    finalPos = chunk.position_3d;
                }
                mesh.position.set(finalPos[0], finalPos[1], finalPos[2]);

                // Store metadata on mesh (include document/nebula for hierarchical selection)
                mesh.userData = {
                    chunkId: chunkId,
                    documentId: chunk.document_id || chunk.documentId,
                    nebulaId: chunk.nebula_id || chunk.nebulaId,
                    content: chunk.content || '',
                    embedding: chunk.embedding || [],
                    tags: chunk.tags || []
                };

                // Animate in: start small and transparent at origin
                mesh.scale.set(0.1, 0.1, 0.1);
                material.transparent = true;
                material.opacity = 0;

                // Add to scene and map
                scene.add(mesh);
                chunkMeshes.set(chunkId, mesh);

                // Animate to final scale and position
                const startScale = new THREE.Vector3(0.1, 0.1, 0.1);
                const endScale = new THREE.Vector3(1, 1, 1);
                const startPos = new THREE.Vector3(0, 0, 0);
                const endPos = new THREE.Vector3(finalPos[0], finalPos[1], finalPos[2]);

                const startTime = performance.now();
                const duration = 800; // ms

                function animateChunk(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Easing function (ease-out)
                    const easeProgress = 1 - Math.pow(1 - progress, 3);

                    // Animate scale
                    mesh.scale.lerpVectors(startScale, endScale, easeProgress);

                    // Animate position
                    mesh.position.lerpVectors(startPos, endPos, easeProgress);

                    // Animate opacity
                    material.opacity = easeProgress;

                    if (progress < 1) {
                        requestAnimationFrame(animateChunk);
                    } else {
                        material.transparent = false;
                    }
                }

                requestAnimationFrame(animateChunk);

                log('DEBUG', `Added chunk ${chunkId} with animation`);
                updateStatusBar();

            } catch (error) {
                log('ERROR', `Failed to add chunk: ${error.message}`);
            }
        }

        /**
         * Deselect all selections
         */
        function deselectAll() {
            if (selectedMesh) {
                selectedMesh.material.emissiveIntensity = 0.2;
                selectedMesh = null;
            }
            selectedDocumentId = null;
            selectedNebulaId = null;
            log('INFO', '‚óá Deselected all');
            updateRotationCenter();
        }

        /**
         * Focus on a specific chunk
         */
        function focusOnChunk(mesh) {
            // Deselect previous mesh
            if (selectedMesh) {
                selectedMesh.material.emissiveIntensity = 0.2;
            }

            // Select new chunk (also selects its document)
            selectedMesh = mesh;
            selectedDocumentId = mesh.userData.documentId;
            selectedNebulaId = mesh.userData.nebulaId;
            mesh.material.emissiveIntensity = 0.8;

            const chunkId = mesh.userData.chunkId;
            const docId = mesh.userData.documentId;
            const content = mesh.userData.content;

            log('INFO', `üìå Selected chunk: ${chunkId}`);
            if (docId) log('DEBUG', `  Document: ${docId}`);
            log('DEBUG', `Content: ${content.substring(0, 80)}...`);

            // Animate camera to focus on chunk
            const targetPos = mesh.position.clone();
            const distance = 25; // How close to zoom
            const direction = targetPos.clone().normalize();
            const cameraTarget = targetPos.clone().add(direction.multiplyScalar(distance));

            // Smooth animation to new position
            const startPos = camera.position.clone();
            const startTime = Date.now();
            const duration = 600; // ms

            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = progress < 0.5
                    ? 2 * progress * progress
                    : -1 + (4 - 2 * progress) * progress;

                camera.position.lerpVectors(startPos, cameraTarget, easeProgress);
                camera.lookAt(targetPos);

                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }

            animateCamera();
        }

        /**
         * Focus on a document (all its chunks)
         */
        function focusOnDocument(documentId) {
            deselectAll();
            selectedDocumentId = documentId;

            // Find and highlight all chunks in document
            const docChunks = Array.from(chunkMeshes.values()).filter(
                mesh => mesh.userData.documentId === documentId
            );

            log('INFO', `üìÑ Selected document: ${documentId} (${docChunks.length} chunks)`);

            // Animate camera to document centroid
            const centroid = calculateCentroid(docChunks);
            const distance = 50;
            const direction = centroid.clone().normalize();
            const cameraTarget = centroid.clone().add(direction.multiplyScalar(distance));

            const startPos = camera.position.clone();
            const startTime = performance.now();
            const duration = 600;

            function animateCamera(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = progress < 0.5
                    ? 2 * progress * progress
                    : -1 + (4 - 2 * progress) * progress;

                camera.position.lerpVectors(startPos, cameraTarget, easeProgress);
                camera.lookAt(centroid);

                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }

            requestAnimationFrame(animateCamera);
            updateRotationCenter();
        }

        /**
         * Focus on a nebula (all its documents)
         */
        function focusOnNebula(nebulaId) {
            deselectAll();
            selectedNebulaId = nebulaId;

            // Find and highlight all chunks in nebula
            const nebulaChunks = Array.from(chunkMeshes.values()).filter(
                mesh => mesh.userData.nebulaId === nebulaId
            );

            log('INFO', `‚òÅÔ∏è Selected nebula: ${nebulaId} (${nebulaChunks.length} chunks)`);

            // Animate camera to nebula centroid
            const centroid = calculateCentroid(nebulaChunks);
            const distance = 80;
            const direction = centroid.clone().normalize();
            const cameraTarget = centroid.clone().add(direction.multiplyScalar(distance));

            const startPos = camera.position.clone();
            const startTime = performance.now();
            const duration = 600;

            function animateCamera(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = progress < 0.5
                    ? 2 * progress * progress
                    : -1 + (4 - 2 * progress) * progress;

                camera.position.lerpVectors(startPos, cameraTarget, easeProgress);
                camera.lookAt(centroid);

                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }

            requestAnimationFrame(animateCamera);
            updateRotationCenter();
        }

        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', () => {
            log('INFO', 'üé¨ Initializing Headspace Debug Mode');
            initScene();
            log('SUCCESS', 'Ready! Enter a document and click "Process & Visualize"');

            document.getElementById('process-btn').addEventListener('click', processDocument);
            document.getElementById('document-content').addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    processDocument();
                }
            });

            // Demo content
            document.getElementById('document-title').value = 'Quantum Computing';
            document.getElementById('document-content').value =
                `Quantum computing represents a fundamental shift in computation. It leverages quantum mechanical phenomena like superposition and entanglement.

Quantum bits or qubits are the basic unit. Unlike classical bits which are 0 or 1, qubits can exist in a superposition of both states simultaneously.

Quantum entanglement allows pairs of qubits to be correlated in ways that have no classical equivalent. This creates powerful computational capabilities.

Quantum gates are operations applied to qubits. They manipulate the quantum states and create interference patterns that amplify correct answers.

The measurement problem in quantum mechanics means that measuring a quantum system collapses its state to a definite value.`;
        });
    </script>
</body>
</html>
